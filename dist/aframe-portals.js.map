{"version":3,"file":"aframe-portals.js","sources":["../src/portal.js","../src/portal-manager.js","../src/utils.js"],"sourcesContent":["AFRAME.registerComponent('portal', {\r\n  schema: {\r\n    destination: { default: '' },\r\n    width: { default: 2 },\r\n    height: { default: 3 },\r\n    maxRecursion: { default: 0 },\r\n    player: { default: '' },\r\n    teleportCooldown: { default: 100 }, //in ms\r\n    enableTeleport: { default: true },\r\n  },\r\n\r\n  init: function () {\r\n    const el = this.el;\r\n    const sceneEl = el.sceneEl;\r\n    const data = this.data;\r\n\r\n    el.justTeleported = false;\r\n    el.isCameraColliding = false;\r\n\r\n    //portal mesh\r\n    const geometry = new THREE.BoxBufferGeometry(data.width, data.height, 0.0001);\r\n    const material = new THREE.MeshBasicMaterial({ colorWrite: false });\r\n    const mesh = new THREE.Mesh(geometry, material);\r\n    mesh.name = 'portal-surface';\r\n\r\n    el.object3D.add(mesh);\r\n\r\n    sceneEl.addEventListener('portal-teleported', () => {\r\n      el.justTeleported = true;\r\n    });\r\n\r\n    el.addEventListener('camera-collision-start', function () {\r\n      if (data.enableTeleport == false) return;\r\n      if (el.justTeleported === true) return;\r\n      el.justTeleported = true;\r\n      sceneEl.emit('portal-teleported');\r\n\r\n      //teleport the player\r\n      const camera = sceneEl.camera;\r\n      const cameraEl = camera.el;\r\n\r\n      const player = sceneEl.player.object3D || cameraEl;\r\n      const destPortal = document.querySelector(data.destination).object3D;\r\n\r\n      const srcRotation = el.object3D.rotation;\r\n      const dstRotation = destPortal.rotation;\r\n\r\n      const deltaRotation = new THREE.Euler(\r\n        srcRotation.x - dstRotation.x,\r\n        srcRotation.y - dstRotation.y + Math.PI,\r\n        srcRotation.z - dstRotation.z\r\n      );\r\n\r\n      if (cameraEl.components['look-controls']) {\r\n        cameraEl.components['look-controls'].yawObject.rotation.y -= deltaRotation.y;\r\n      }\r\n\r\n      const bufferDistance = 0.075; //teleports the player this distance away from the exit portal\r\n      const buffer = el.object3D.getWorldDirection(new THREE.Vector3()).multiplyScalar(bufferDistance);\r\n\r\n      const playerPosition = player.getWorldPosition(new THREE.Vector3());\r\n      const portalPosition = el.object3D.getWorldPosition(new THREE.Vector3());\r\n\r\n      const deltaPosition = new THREE.Vector3().subVectors(playerPosition, portalPosition).sub(buffer);\r\n\r\n      const rotatedDeltaPosition = deltaPosition.clone();\r\n      const theta = deltaRotation.y;\r\n      rotatedDeltaPosition.x = deltaPosition.x * Math.cos(theta) - deltaPosition.z * Math.sin(theta);\r\n      rotatedDeltaPosition.z = deltaPosition.x * Math.sin(theta) + deltaPosition.z * Math.cos(theta);\r\n\r\n      const destPosition = destPortal.position.clone().add(rotatedDeltaPosition);\r\n\r\n      player.position.x = destPosition.x;\r\n      player.position.y = destPosition.y;\r\n      player.position.z = destPosition.z;\r\n    });\r\n\r\n    //use sceneEl to store state\r\n    if (!sceneEl.portals) {\r\n      sceneEl.portals = [];\r\n    }\r\n\r\n    //if there is not already a portal-manager entity, create one\r\n    if (Array.from(sceneEl.children).reduce((acc, c) => acc || c.hasAttribute('portal-manager'), false) === false) {\r\n      const entity = document.createElement('a-entity');\r\n      entity.setAttribute('portal-manager', { maxRecursion: data.maxRecursion });\r\n      sceneEl.appendChild(entity);\r\n    }\r\n\r\n    //add this portal to the 'portals' list\r\n    const portals = sceneEl.portals;\r\n    const dest = document.querySelector(data.destination);\r\n\r\n    const portalObj = {\r\n      portal: el.object3D,\r\n      destination: dest.object3D,\r\n      maxRecursion: data.maxRecursion,\r\n      player: data.player,\r\n      distance: 0,\r\n    };\r\n    portals.push(portalObj);\r\n  },\r\n\r\n  tick: function () {\r\n    const el = this.el;\r\n    if (el.justTeleported === true)\r\n      setTimeout(() => {\r\n        el.justTeleported = false;\r\n      }, this.data.teleportCooldown);\r\n  },\r\n});\r\n","import { computeViewMatrix, computeProjectionMatrix } from './utils';\r\n\r\nAFRAME.registerComponent('portal-manager', {\r\n  schema: {\r\n    skipTicks: { default: 25 },\r\n    maxRecursion: { default: 0 },\r\n    player: { default: '' },\r\n  },\r\n\r\n  init: function () {\r\n    const data = this.data;\r\n    const sceneEl = this.el.sceneEl;\r\n\r\n    data.ticks = 0;\r\n    data.maxRecursion = sceneEl.portals.reduce((acc, obj) => Math.max(acc, obj.maxRecursion), data.maxRecursion);\r\n\r\n    const playerSelector = sceneEl.portals.reduce((acc, obj) => acc || obj.player, data.player);\r\n    if (playerSelector) {\r\n      this.el.sceneEl.player = document.querySelector(playerSelector);\r\n    }\r\n  },\r\n\r\n  tick: function () {\r\n    const data = this.data;\r\n    const sceneEl = this.el.sceneEl;\r\n    const portals = sceneEl.portals;\r\n\r\n    if (data.ticks % data.skipTicks === 0) {\r\n      //sort portals by distance to camera\r\n      //render the farthest portals first\r\n      const cameraPosition = sceneEl.camera.getWorldPosition(new THREE.Vector3());\r\n      portals.forEach((obj) => {\r\n        obj.distance = obj.portal.getWorldPosition(new THREE.Vector3()).distanceTo(cameraPosition);\r\n      });\r\n      portals.sort((a, b) => b.distance - a.distance);\r\n    }\r\n\r\n    data.ticks++;\r\n  },\r\n\r\n  tock: function () {\r\n    const sceneEl = this.el.sceneEl;\r\n    const camera = sceneEl.camera;\r\n    const renderer = sceneEl.renderer;\r\n\r\n    this.renderRecursivePortals(renderer, camera, 0);\r\n    this.collisionDetection();\r\n  },\r\n\r\n  renderRecursivePortals: function (renderer, camera, recursionLevel) {\r\n    const sceneEl = this.el.sceneEl;\r\n    const portals = sceneEl.portals;\r\n\r\n    const gl = renderer.getContext();\r\n    const tmpScene = sceneEl.object3D.clone();\r\n\r\n    renderer.autoClear = false;\r\n    camera.matrixAutoUpdate = false;\r\n\r\n    portals.forEach((obj) => {\r\n      const portal = obj.portal;\r\n      const destPortal = obj.destination;\r\n\r\n      gl.colorMask(false, false, false, false);\r\n      gl.depthMask(false);\r\n      gl.disable(gl.DEPTH_TEST);\r\n      gl.enable(gl.STENCIL_TEST);\r\n      gl.stencilFunc(gl.NOTEQUAL, recursionLevel, 0xff);\r\n      gl.stencilOp(gl.INCR, gl.KEEP, gl.KEEP);\r\n      gl.stencilMask(0xff);\r\n\r\n      //render portal into stencil buffer\r\n      renderer.render(portal, camera);\r\n\r\n      const virtualCam = camera.clone();\r\n      virtualCam.matrixWorld = computeViewMatrix(camera, portal, destPortal);\r\n      //projection matrix for frustrum clipping\r\n      virtualCam.projectionMatrix = computeProjectionMatrix(\r\n        destPortal,\r\n        virtualCam.matrixWorld,\r\n        virtualCam.projectionMatrix\r\n      );\r\n\r\n      if (recursionLevel == this.data.maxRecursion) {\r\n        gl.colorMask(true, true, true, true);\r\n        gl.depthMask(true);\r\n        renderer.clear(false, true, false);\r\n        gl.enable(gl.DEPTH_TEST);\r\n        gl.enable(gl.STENCIL_TEST);\r\n        gl.stencilMask(0x00);\r\n        gl.stencilFunc(gl.EQUAL, recursionLevel + 1, 0xff);\r\n\r\n        //render the rest of the scene, limited to the stencil buffer\r\n        renderer.render(tmpScene, virtualCam);\r\n      } else {\r\n        //recursion\r\n        this.renderRecursivePortals(renderer, virtualCam, recursionLevel + 1);\r\n      }\r\n\r\n      gl.colorMask(false, false, false, false);\r\n      gl.depthMask(false);\r\n      gl.enable(gl.STENCIL_TEST);\r\n      gl.stencilMask(0xff);\r\n      gl.stencilFunc(gl.NOTEQUAL, recursionLevel + 1, 0xff);\r\n      gl.stencilOp(gl.DECR, gl.KEEP, gl.KEEP);\r\n\r\n      //render portal into stencil buffer\r\n      renderer.render(portal, camera);\r\n    });\r\n\r\n    gl.disable(gl.STENCIL_TEST);\r\n    gl.stencilMask(0x00);\r\n    gl.colorMask(false, false, false, false);\r\n    gl.enable(gl.DEPTH_TEST);\r\n    gl.depthMask(true);\r\n    gl.depthFunc(gl.ALWAYS);\r\n    renderer.clear(false, true, false);\r\n\r\n    //render portals into depth buffer\r\n    portals.forEach((obj) => {\r\n      renderer.render(obj.portal, camera);\r\n    });\r\n\r\n    gl.depthFunc(gl.LESS);\r\n    gl.enable(gl.STENCIL_TEST);\r\n    gl.stencilMask(0x00);\r\n    gl.stencilFunc(gl.LEQUAL, recursionLevel, 0xff);\r\n    gl.colorMask(true, true, true, true);\r\n    gl.depthMask(true);\r\n\r\n    //render the rest of the scene, but only at recursionLevel\r\n    renderer.render(tmpScene, camera);\r\n\r\n    camera.matrixAutoUpdate = true;\r\n  },\r\n\r\n  collisionDetection: function () {\r\n    const sceneEl = this.el.sceneEl;\r\n    const portals = sceneEl.portals;\r\n    const camera = sceneEl.camera;\r\n\r\n    //portal collision detection\r\n    const collisions = portals.map((obj) => {\r\n      const portal = obj.portal;\r\n      const mesh = portal.children.filter((c) => c.name == 'portal-surface')[0];\r\n      const bbox = new THREE.Box3().setFromObject(mesh);\r\n      const bounds = {\r\n        portal: portal,\r\n        xMin: bbox.min.x,\r\n        xMax: bbox.max.x,\r\n        yMin: bbox.min.y,\r\n        yMax: bbox.max.y,\r\n        zMin: bbox.min.z,\r\n        zMax: bbox.max.z,\r\n      };\r\n      return bounds;\r\n    });\r\n\r\n    const width = 0.1; //width of user hitbox, arbitrary number\r\n\r\n    //calculate user bounds\r\n    const camPos = camera.getWorldPosition(new THREE.Vector3());\r\n    const bounds = {\r\n      xMin: camPos.x - width / 2,\r\n      xMax: camPos.x + width / 2,\r\n      yMin: camPos.y - width / 2,\r\n      yMax: camPos.y + width / 2,\r\n      zMin: camPos.z - width / 2,\r\n      zMax: camPos.z + width / 2,\r\n    };\r\n\r\n    collisions.forEach((obj) => {\r\n      if (\r\n        bounds.xMin <= obj.xMax &&\r\n        bounds.xMax >= obj.xMin &&\r\n        bounds.yMin <= obj.yMax &&\r\n        bounds.yMax >= obj.yMin &&\r\n        bounds.zMin <= obj.zMax &&\r\n        bounds.zMax >= obj.zMin\r\n      ) {\r\n        //there is a collision\r\n        const portalEl = obj.portal.el;\r\n        if (portalEl.isCameraColliding === false) {\r\n          portalEl.emit('camera-collision-start');\r\n          portalEl.isCameraColliding = true;\r\n        }\r\n      } else {\r\n        const portalEl = obj.portal.el;\r\n        if (portalEl.isCameraColliding === true) {\r\n          portalEl.emit('camera-collision-end');\r\n          portalEl.isCameraColliding = false;\r\n        }\r\n      }\r\n    });\r\n  },\r\n});\r\n","export const computeViewMatrix = (camera, src, dst) => {\r\n  const srcToCam = camera.matrixWorld.clone();\r\n  srcToCam.invert().multiply(src.matrixWorld);\r\n\r\n  const dstInverse = dst.matrixWorld.clone().invert();\r\n  const rotationYMatrix = new THREE.Matrix4().makeRotationY(Math.PI);\r\n  const srcToDst = new THREE.Matrix4().multiply(srcToCam).multiply(rotationYMatrix).multiply(dstInverse);\r\n\r\n  return srcToDst.invert();\r\n};\r\n\r\nexport const computeProjectionMatrix = (dst, viewMat, projMat) => {\r\n  const cameraInverseViewMat = viewMat.clone().invert();\r\n\r\n  const dstRotationMatrix = new THREE.Matrix4().extractRotation(dst.matrixWorld);\r\n\r\n  const normal = new THREE.Vector3().set(0, 0, 1).applyMatrix4(dstRotationMatrix);\r\n\r\n  const clipPlane = new THREE.Plane();\r\n  clipPlane.setFromNormalAndCoplanarPoint(normal, dst.getWorldPosition(new THREE.Vector3()));\r\n  clipPlane.applyMatrix4(cameraInverseViewMat);\r\n\r\n  const clipVector = new THREE.Vector4();\r\n  clipVector.set(clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant);\r\n\r\n  const projectionMatrix = projMat.clone();\r\n\r\n  const q = new THREE.Vector4();\r\n  q.x = (Math.sign(clipVector.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];\r\n  q.y = (Math.sign(clipVector.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];\r\n  q.z = -1.0;\r\n  q.w = (1.0 + projectionMatrix.elements[10]) / projMat.elements[14];\r\n\r\n  clipVector.multiplyScalar(2 / clipVector.dot(q));\r\n\r\n  projectionMatrix.elements[2] = clipVector.x;\r\n  projectionMatrix.elements[6] = clipVector.y;\r\n  projectionMatrix.elements[10] = clipVector.z + 1.0;\r\n  projectionMatrix.elements[14] = clipVector.w;\r\n\r\n  return projectionMatrix;\r\n};\r\n"],"names":["AFRAME","registerComponent","schema","destination","default","width","height","maxRecursion","player","teleportCooldown","enableTeleport","init","el","this","sceneEl","data","justTeleported","isCameraColliding","geometry","THREE","BoxBufferGeometry","material","MeshBasicMaterial","colorWrite","mesh","Mesh","name","object3D","add","addEventListener","emit","cameraEl","camera","destPortal","document","querySelector","srcRotation","rotation","dstRotation","deltaRotation","Euler","x","y","Math","PI","z","components","yawObject","buffer","getWorldDirection","Vector3","multiplyScalar","playerPosition","getWorldPosition","portalPosition","deltaPosition","subVectors","sub","rotatedDeltaPosition","clone","theta","cos","sin","destPosition","position","portals","Array","from","children","reduce","acc","c","hasAttribute","entity","createElement","setAttribute","appendChild","dest","push","portal","distance","tick","setTimeout","skipTicks","ticks","obj","max","playerSelector","cameraPosition","forEach","distanceTo","sort","a","b","tock","renderRecursivePortals","renderer","collisionDetection","recursionLevel","gl","getContext","tmpScene","autoClear","matrixAutoUpdate","colorMask","depthMask","disable","DEPTH_TEST","enable","STENCIL_TEST","stencilFunc","NOTEQUAL","stencilOp","INCR","KEEP","stencilMask","render","virtualCam","matrixWorld","src","dst","srcToCam","invert","multiply","dstInverse","rotationYMatrix","Matrix4","makeRotationY","computeViewMatrix","projectionMatrix","viewMat","projMat","cameraInverseViewMat","dstRotationMatrix","extractRotation","normal","set","applyMatrix4","clipPlane","Plane","setFromNormalAndCoplanarPoint","clipVector","Vector4","constant","q","sign","elements","w","dot","computeProjectionMatrix","_this","clear","EQUAL","DECR","depthFunc","ALWAYS","LESS","LEQUAL","collisions","map","filter","bbox","Box3","setFromObject","xMin","min","xMax","yMin","yMax","zMin","zMax","camPos","bounds","portalEl"],"mappings":"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"}