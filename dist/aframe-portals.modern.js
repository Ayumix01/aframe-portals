AFRAME.registerComponent("portal",{schema:{destination:{default:""},width:{default:2},height:{default:3},maxRecursion:{default:0},teleportCooldown:{default:100},enableTeleport:{default:!0}},init:function(){const e=this.el,t=e.sceneEl,o=this.data;e.justTeleported=!1,e.isCameraColliding=!1;const n=new THREE.BoxBufferGeometry(o.width,o.height,1e-4),a=new THREE.MeshBasicMaterial,i=new THREE.Mesh(n,a);if(i.name="portal-surface",e.object3D.add(i),t.addEventListener("portal-teleported",()=>{e.justTeleported=!0}),e.addEventListener("camera-collision-start",function(){if(0==o.enableTeleport)return;if(!0===e.justTeleported)return;e.justTeleported=!0,t.emit("portal-teleported");const n=t.camera,a=n.el,i=document.querySelector(o.destination).object3D,r=e.object3D.rotation,s=i.rotation,l=new THREE.Euler(r.x-s.x,r.y-s.y+Math.PI,r.z-s.z);a.components["look-controls"]&&(a.components["look-controls"].yawObject.rotation.y-=l.y);const c=e.object3D.getWorldDirection(new THREE.Vector3).multiplyScalar(.075),d=n.getWorldPosition(new THREE.Vector3),E=e.object3D.getWorldPosition(new THREE.Vector3),m=(new THREE.Vector3).subVectors(d,E).sub(c),p=m.clone(),u=l.y;p.x=m.x*Math.cos(u)-m.z*Math.sin(u),p.z=m.x*Math.sin(u)+m.z*Math.cos(u);const T=i.position.clone().add(p);a.object3D.position.x=T.x,a.object3D.position.y=T.y,a.object3D.position.z=T.z}),t.portals||(t.portals=[]),!1===Array.from(t.children).reduce((e,t)=>e||t.hasAttribute("portal-manager"),!1)){const e=document.createElement("a-entity");e.setAttribute("portal-manager",{maxRecursion:o.maxRecursion}),t.appendChild(e)}const r=t.portals,s=document.querySelector(o.destination);r.push({portal:e.object3D,destination:s.object3D,maxRecursion:o.maxRecursion,distance:0})},tick:function(){const e=this.el;!0===e.justTeleported&&setTimeout(()=>{e.justTeleported=!1},this.data.teleportCooldown)}}),AFRAME.registerComponent("portal-manager",{schema:{skipTicks:{default:25},maxRecursion:{default:0}},init:function(){const e=this.data,t=this.el.sceneEl;e.ticks=0,e.maxRecursion=t.portals.reduce((e,t)=>Math.max(e,t.maxRecursion),e.maxRecursion)},tick:function(){const e=this.data,t=this.el.sceneEl,o=t.portals;if(e.ticks%e.skipTicks==0){const e=t.camera.getWorldPosition(new THREE.Vector3);o.forEach(t=>{t.distance=t.portal.getWorldPosition(new THREE.Vector3).distanceTo(e)}),o.sort((e,t)=>t.distance-e.distance)}e.ticks++},tock:function(){const e=this.el.sceneEl;this.renderRecursivePortals(e.renderer,e.camera,0),this.collisionDetection()},renderRecursivePortals:function(e,t,o){const n=this.el.sceneEl,a=n.portals,i=e.getContext(),r=n.object3D.clone();e.autoClear=!1,t.matrixAutoUpdate=!1,a.forEach(n=>{const a=n.portal,s=n.destination;i.colorMask(!1,!1,!1,!1),i.depthMask(!1),i.disable(i.DEPTH_TEST),i.enable(i.STENCIL_TEST),i.stencilFunc(i.NOTEQUAL,o,255),i.stencilOp(i.INCR,i.KEEP,i.KEEP),i.stencilMask(255),e.render(a,t);const l=(new THREE.PerspectiveCamera).copy(t);l.matrixWorld=function(e,t,o){const n=e.matrixWorld.clone();n.invert().multiply(t.matrixWorld);const a=o.matrixWorld.clone().invert(),i=(new THREE.Matrix4).makeRotationY(Math.PI);return(new THREE.Matrix4).multiply(n).multiply(i).multiply(a).invert()}(t,a,s),l.projectionMatrix=function(e,t,o){const n=t.clone().invert(),a=(new THREE.Matrix4).extractRotation(e.matrixWorld),i=(new THREE.Vector3).set(0,0,1).applyMatrix4(a),r=new THREE.Plane;r.setFromNormalAndCoplanarPoint(i,e.getWorldPosition(new THREE.Vector3)),r.applyMatrix4(n);const s=new THREE.Vector4;s.set(r.normal.x,r.normal.y,r.normal.z,r.constant);const l=o.clone(),c=new THREE.Vector4;return c.x=(Math.sign(s.x)+l.elements[8])/l.elements[0],c.y=(Math.sign(s.y)+l.elements[9])/l.elements[5],c.z=-1,c.w=(1+l.elements[10])/o.elements[14],s.multiplyScalar(2/s.dot(c)),l.elements[2]=s.x,l.elements[6]=s.y,l.elements[10]=s.z+1,l.elements[14]=s.w,l}(s,l.matrixWorld,l.projectionMatrix),o==this.data.maxRecursion?(i.colorMask(!0,!0,!0,!0),i.depthMask(!0),e.clear(!1,!0,!1),i.enable(i.DEPTH_TEST),i.enable(i.STENCIL_TEST),i.stencilMask(0),i.stencilFunc(i.EQUAL,o+1,255),e.render(r,l)):this.renderRecursivePortals(e,l,o+1),i.colorMask(!1,!1,!1,!1),i.depthMask(!1),i.enable(i.STENCIL_TEST),i.stencilMask(255),i.stencilFunc(i.NOTEQUAL,o+1,255),i.stencilOp(i.DECR,i.KEEP,i.KEEP),e.render(a,t)}),i.disable(i.STENCIL_TEST),i.stencilMask(0),i.colorMask(!1,!1,!1,!1),i.enable(i.DEPTH_TEST),i.depthMask(!0),i.depthFunc(i.ALWAYS),e.clear(!1,!0,!1),a.forEach(o=>{e.render(o.portal,t)}),i.depthFunc(i.LESS),i.enable(i.STENCIL_TEST),i.stencilMask(0),i.stencilFunc(i.LEQUAL,o,255),i.colorMask(!0,!0,!0,!0),i.depthMask(!0),e.render(r,t),t.matrixAutoUpdate=!0},collisionDetection:function(){const e=this.el.sceneEl,t=e.camera,o=e.portals.map(e=>{const t=e.portal,o=t.children.filter(e=>"portal-surface"==e.name)[0],n=(new THREE.Box3).setFromObject(o);return{portal:t,xMin:n.min.x,xMax:n.max.x,yMin:n.min.y,yMax:n.max.y,zMin:n.min.z,zMax:n.max.z}}),n=t.getWorldPosition(new THREE.Vector3),a=n.x-.05,i=n.x+.05,r=n.y-.05,s=n.y+.05,l=n.z-.05,c=n.z+.05;o.forEach(e=>{if(a<=e.xMax&&i>=e.xMin&&r<=e.yMax&&s>=e.yMin&&l<=e.zMax&&c>=e.zMin){const t=e.portal.el;!1===t.isCameraColliding&&(t.emit("camera-collision-start"),t.isCameraColliding=!0)}else{const t=e.portal.el;!0===t.isCameraColliding&&(t.emit("camera-collision-end"),t.isCameraColliding=!1)}})}});
//# sourceMappingURL=aframe-portals.modern.js.map
